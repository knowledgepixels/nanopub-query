<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MainVerticle.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Nanopub Query</a> &gt; <a href="index.source.html" class="el_package">com.knowledgepixels.query</a> &gt; <span class="el_source">MainVerticle.java</span></div><h1>MainVerticle.java</h1><pre class="source lang-java linenums">package com.knowledgepixels.query;

import java.io.InputStream;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map.Entry;
import java.util.Scanner;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import org.eclipse.rdf4j.model.Value;

import com.github.jsonldjava.shaded.com.google.common.base.Charsets;

import io.micrometer.prometheus.PrometheusMeterRegistry;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.MultiMap;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpClient;
import io.vertx.core.http.HttpClientOptions;
import io.vertx.core.http.HttpMethod;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.http.PoolOptions;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.CorsHandler;
import io.vertx.ext.web.handler.StaticHandler;
import io.vertx.ext.web.proxy.handler.ProxyHandler;
import io.vertx.httpproxy.HttpProxy;
import io.vertx.httpproxy.ProxyContext;
import io.vertx.httpproxy.ProxyInterceptor;
import io.vertx.httpproxy.ProxyRequest;
import io.vertx.httpproxy.ProxyResponse;
import io.vertx.micrometer.PrometheusScrapingHandler;
import io.vertx.micrometer.backends.BackendRegistries;

/**
 * Main verticle that coordinates the incoming HTTP requests.
 */
@GeneratedFlagForDependentElements
public class MainVerticle extends AbstractVerticle {

    private static String css = null;

    /**
     * Start the main verticle.
     *
     * @param startPromise the promise to complete when the verticle is started
     * @throws Exception if an error occurs during startup
     */
    @Override
    public void start(Promise&lt;Void&gt; startPromise) throws Exception {
        HttpClient httpClient = vertx.createHttpClient(
                new HttpClientOptions()
                        .setConnectTimeout(Utils.getEnvInt(&quot;NANOPUB_QUERY_VERTX_CONNECT_TIMEOUT&quot;, 1000))
                        .setIdleTimeoutUnit(TimeUnit.SECONDS)
                        .setIdleTimeout(Utils.getEnvInt(&quot;NANOPUB_QUERY_VERTX_IDLE_TIMEOUT&quot;, 60))
                        .setReadIdleTimeout(Utils.getEnvInt(&quot;NANOPUB_QUERY_VERTX_IDLE_TIMEOUT&quot;, 60))
                        .setWriteIdleTimeout(Utils.getEnvInt(&quot;NANOPUB_QUERY_VERTX_IDLE_TIMEOUT&quot;, 60)),
                new PoolOptions().setHttp1MaxSize(200).setHttp2MaxSize(200)
        );

        HttpServer proxyServer = vertx.createHttpServer();
        Router proxyRouter = Router.router(vertx);
        proxyRouter.route().handler(CorsHandler.create().addRelativeOrigin(&quot;.*&quot;));

        // Metrics
        final var metricsHttpServer = vertx.createHttpServer();
        final var metricsRouter = Router.router(vertx);
        metricsHttpServer.requestHandler(metricsRouter).listen(9394);

        final var metricsRegistry = (PrometheusMeterRegistry) BackendRegistries.getDefaultNow();
        final var collector = new MetricsCollector(metricsRegistry);
        metricsRouter.route(&quot;/metrics&quot;).handler(PrometheusScrapingHandler.create(metricsRegistry));
        // ----------
        // This part is only used if the redirection is not done through Nginx.
        // See nginx.conf and this bug report: https://github.com/eclipse-rdf4j/rdf4j/discussions/5120
        HttpProxy rdf4jProxy = HttpProxy.reverseProxy(httpClient);
        String proxy = Utils.getEnvString(&quot;RDF4J_PROXY_HOST&quot;, &quot;rdf4j&quot;);
        int proxyPort = Utils.getEnvInt(&quot;RDF4J_PROXY_PORT&quot;, 8080);
        rdf4jProxy.origin(proxyPort, proxy);

<span class="nc" id="L87">        rdf4jProxy.addInterceptor(new ProxyInterceptor() {</span>

            @Override
            public Future&lt;ProxyResponse&gt; handleProxyRequest(ProxyContext context) {
<span class="nc" id="L91">                ProxyRequest request = context.request();</span>
<span class="nc" id="L92">                request.setURI(request.getURI().replaceAll(&quot;/&quot;, &quot;_&quot;).replaceFirst(&quot;^_repo_&quot;, &quot;/rdf4j-server/repositories/&quot;));</span>
                // For later to try to get HTML tables out:
//				if (request.headers().get(&quot;Accept&quot;) == null) {
//					request.putHeader(&quot;Accept&quot;, &quot;text/html&quot;);
//				}
//				request.putHeader(&quot;Accept&quot;, &quot;application/json&quot;);
<span class="nc" id="L98">                return ProxyInterceptor.super.handleProxyRequest(context);</span>
            }

            @Override
            public Future&lt;Void&gt; handleProxyResponse(ProxyContext context) {
<span class="nc" id="L103">                ProxyResponse resp = context.response();</span>
<span class="nc" id="L104">                resp.putHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span>
<span class="nc" id="L105">                resp.putHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS&quot;);</span>
                // For later to try to get HTML tables out:
//				String acceptHeader = context.request().headers().get(&quot;Accept&quot;);
//				if (acceptHeader != null &amp;&amp; acceptHeader.contains(&quot;text/html&quot;)) {
//					resp.putHeader(&quot;Content-Type&quot;, &quot;text/html&quot;);
//					resp.setBody(Body.body(Buffer.buffer(&quot;&lt;html&gt;&lt;body&gt;&lt;strong&gt;test&lt;/strong&gt;&lt;/body&gt;&lt;/html&gt;&quot;)));
//				}
<span class="nc" id="L112">                return ProxyInterceptor.super.handleProxyResponse(context);</span>
            }

        });
        // ----------

        proxyRouter.route(HttpMethod.GET, &quot;/repo&quot;).handler(req -&gt; handleRedirect(req, &quot;/repo&quot;));
        proxyRouter.route(HttpMethod.GET, &quot;/repo/*&quot;).handler(ProxyHandler.create(rdf4jProxy));
        proxyRouter.route(HttpMethod.POST, &quot;/repo/*&quot;).handler(ProxyHandler.create(rdf4jProxy));
        proxyRouter.route(HttpMethod.HEAD, &quot;/repo/*&quot;).handler(ProxyHandler.create(rdf4jProxy));
        proxyRouter.route(HttpMethod.OPTIONS, &quot;/repo/*&quot;).handler(ProxyHandler.create(rdf4jProxy));
        proxyRouter.route(HttpMethod.GET, &quot;/tools/*&quot;).handler(req -&gt; {
            final String yasguiPattern = &quot;^/tools/([a-zA-Z0-9-_]+)(/([a-zA-Z0-9-_]+))?/yasgui\\.html$&quot;;
            if (req.normalizedPath().matches(yasguiPattern)) {
                String repo = req.normalizedPath().replaceFirst(yasguiPattern, &quot;$1$2&quot;);
                req.response()
                        .putHeader(&quot;content-type&quot;, &quot;text/html&quot;)
                        .end(&quot;&lt;!DOCTYPE html&gt;\n&quot;
                                + &quot;&lt;html lang=\&quot;en\&quot;&gt;\n&quot;
                                + &quot;&lt;head&gt;\n&quot;
                                + &quot;&lt;meta charset=\&quot;utf-8\&quot;&gt;\n&quot;
                                + &quot;&lt;meta http-equiv=\&quot;X-UA-Compatible\&quot; content=\&quot;IE=edge\&quot;&gt;\n&quot;
                                + &quot;&lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width, initial-scale=1\&quot;&gt;\n&quot;
                                + &quot;&lt;title&gt;Nanopub Query SPARQL Editor for repository: &quot; + repo + &quot;&lt;/title&gt;\n&quot;
                                + &quot;&lt;link rel=\&quot;stylesheet\&quot; href=\&quot;/style.css\&quot;&gt;\n&quot;
                                + &quot;&lt;link href='https://cdn.jsdelivr.net/yasgui/2.6.1/yasgui.min.css' rel='stylesheet' type='text/css'/&gt;\n&quot;
                                + &quot;&lt;style&gt;.yasgui .endpointText {display:none !important;}&lt;/style&gt;\n&quot;
                                + &quot;&lt;script type=\&quot;text/javascript\&quot;&gt;localStorage.clear();&lt;/script&gt;\n&quot;
                                + &quot;&lt;/head&gt;\n&quot;
                                + &quot;&lt;body&gt;\n&quot;
                                + &quot;&lt;h3&gt;Nanopub Query SPARQL Editor for repository: &quot; + repo + &quot;&lt;/h3&gt;\n&quot;
                                + &quot;&lt;div id='yasgui'&gt;&lt;/div&gt;\n&quot;
                                + &quot;&lt;script src='https://cdn.jsdelivr.net/yasgui/2.6.1/yasgui.min.js'&gt;&lt;/script&gt;\n&quot;
                                + &quot;&lt;script type=\&quot;text/javascript\&quot;&gt;\n&quot;
                                + &quot;var yasgui = YASGUI(document.getElementById(\&quot;yasgui\&quot;), {\n&quot;
                                + &quot;  yasqe:{sparql:{endpoint:'/repo/&quot; + repo + &quot;'},value:'&quot; + Utils.defaultQuery.replaceAll(&quot;\n&quot;, &quot;\\\\n&quot;) + &quot;'}\n&quot;
                                + &quot;});\n&quot;
                                + &quot;&lt;/script&gt;\n&quot;
                                + &quot;&lt;/body&gt;\n&quot;
                                + &quot;&lt;/html&gt;&quot;);
            } else {
                req.response()
                        .putHeader(&quot;content-type&quot;, &quot;text/plain&quot;)
                        .setStatusCode(404)
                        .end(&quot;not found&quot;);
            }
        });
        proxyRouter.route(HttpMethod.GET, &quot;/page&quot;).handler(req -&gt; handleRedirect(req, &quot;/page&quot;));
        proxyRouter.route(HttpMethod.GET, &quot;/page/*&quot;).handler(req -&gt; {
            final String pagePattern = &quot;^/page/([a-zA-Z0-9-_]+)(/([a-zA-Z0-9-_]+))?$&quot;;
            if (req.normalizedPath().matches(pagePattern)) {
                String repo = req.normalizedPath().replaceFirst(pagePattern, &quot;$1$2&quot;);
                req.response()
                        .putHeader(&quot;content-type&quot;, &quot;text/html&quot;)
                        .end(&quot;&lt;!DOCTYPE html&gt;\n&quot;
                                + &quot;&lt;html lang=\&quot;en\&quot;&gt;\n&quot;
                                + &quot;&lt;head&gt;\n&quot;
                                + &quot;&lt;meta charset=\&quot;utf-8\&quot;&gt;\n&quot;
                                + &quot;&lt;meta http-equiv=\&quot;X-UA-Compatible\&quot; content=\&quot;IE=edge\&quot;&gt;\n&quot;
                                + &quot;&lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width, initial-scale=1\&quot;&gt;\n&quot;
                                + &quot;&lt;title&gt;Nanopub Query repo: &quot; + repo + &quot;&lt;/title&gt;\n&quot;
                                + &quot;&lt;link rel=\&quot;stylesheet\&quot; href=\&quot;/style.css\&quot;&gt;\n&quot;
                                + &quot;&lt;/head&gt;\n&quot;
                                + &quot;&lt;body&gt;\n&quot;
                                + &quot;&lt;h3&gt;Nanopub Query repo: &quot; + repo + &quot;&lt;/h3&gt;\n&quot;
                                + &quot;&lt;p&gt;Endpoint: &lt;a href=\&quot;/repo/&quot; + repo + &quot;\&quot;&gt;/repo/&quot; + repo + &quot;&lt;/a&gt;&lt;/p&gt;&quot;
                                + &quot;&lt;p&gt;YASGUI: &lt;a href=\&quot;/tools/&quot; + repo + &quot;/yasgui.html\&quot;&gt;/tools/&quot; + repo + &quot;/yasgui.hml&lt;/a&gt;&lt;/p&gt;&quot;
                                + &quot;&lt;/body&gt;\n&quot;
                                + &quot;&lt;/html&gt;&quot;);
            } else {
                req.response()
                        .putHeader(&quot;content-type&quot;, &quot;text/plain&quot;)
                        .setStatusCode(404)
                        .end(&quot;not found&quot;);
            }
        });
        proxyRouter.route(HttpMethod.GET, &quot;/&quot;).handler(req -&gt; {
            String repos = &quot;&quot;;
            List&lt;String&gt; repoList = new ArrayList&lt;&gt;(TripleStore.get().getRepositoryNames());
            Collections.sort(repoList);
            for (String s : repoList) {
                if (s.startsWith(&quot;pubkey_&quot;) || s.startsWith(&quot;type_&quot;)) continue;
                repos += &quot;&lt;li&gt;&lt;code&gt;&lt;a href=\&quot;/page/&quot; + s + &quot;\&quot;&gt;&quot; + s + &quot;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;&quot;;
            }
            String pinnedApisValue = Utils.getEnvString(&quot;NANOPUB_QUERY_PINNED_APIS&quot;, &quot;&quot;);
            String[] pinnedApis = pinnedApisValue.split(&quot; &quot;);
            String pinnedApiLinks = &quot;&quot;;
            if (!pinnedApisValue.isEmpty()) {
                for (String s : pinnedApis) {
                    pinnedApiLinks = pinnedApiLinks + &quot;&lt;li&gt;&lt;a href=\&quot;openapi/?url=spec/&quot; + s + &quot;%3Fapi-version=latest\&quot;&gt;&quot; + s.replaceFirst(&quot;^.*/&quot;, &quot;&quot;) + &quot;&lt;/a&gt;&lt;/li&gt;&quot;;
                }
                pinnedApiLinks = &quot;&lt;p&gt;Pinned APIs:&lt;/p&gt;\n&quot; +
                        &quot;&lt;ul&gt;\n&quot; +
                        pinnedApiLinks +
                        &quot;&lt;/ul&gt;\n&quot;;
            }
            req.response()
                    .putHeader(&quot;content-type&quot;, &quot;text/html&quot;)
                    .end(&quot;&lt;!DOCTYPE html&gt;\n&quot;
                            + &quot;&lt;html lang='en'&gt;\n&quot;
                            + &quot;&lt;head&gt;\n&quot;
                            + &quot;&lt;title&gt;Nanopub Query&lt;/title&gt;\n&quot;
                            + &quot;&lt;meta charset='utf-8'&gt;\n&quot;
                            + &quot;&lt;link rel=\&quot;stylesheet\&quot; href=\&quot;/style.css\&quot;&gt;\n&quot;
                            + &quot;&lt;/head&gt;\n&quot;
                            + &quot;&lt;body&gt;\n&quot;
                            + &quot;&lt;h1&gt;Nanopub Query&lt;/h1&gt;&quot;
                            + &quot;&lt;p&gt;General repos:&lt;/p&gt;&quot;
                            + &quot;&lt;ul&gt;&quot; + repos + &quot;&lt;/ul&gt;&quot;
                            + &quot;&lt;p&gt;Specific repos:&lt;/p&gt;&quot;
                            + &quot;&lt;ul&gt;&quot;
                            + &quot;&lt;li&gt;&lt;a href=\&quot;/pubkeys\&quot;&gt;Pubkey Repos&lt;/a&gt;&lt;/li&gt;&quot;
                            + &quot;&lt;li&gt;&lt;a href=\&quot;/types\&quot;&gt;Type Repos&lt;/a&gt;&lt;/li&gt;&quot;
                            + &quot;&lt;/ul&gt;&quot;
                            + pinnedApiLinks
                            + &quot;&lt;/body&gt;\n&quot;
                            + &quot;&lt;/html&gt;&quot;);
        });
        proxyRouter.route(HttpMethod.GET, &quot;/pubkeys&quot;).handler(req -&gt; {
            String repos = &quot;&quot;;
            List&lt;String&gt; repoList = new ArrayList&lt;&gt;(TripleStore.get().getRepositoryNames());
            Collections.sort(repoList);
            for (String s : repoList) {
                if (!s.startsWith(&quot;pubkey_&quot;)) continue;
                String hash = s.replaceFirst(&quot;^([a-zA-Z0-9-]+)_([a-zA-Z0-9-_]+)$&quot;, &quot;$2&quot;);
                Value hashObj = Utils.getObjectForHash(hash);
                String label;
                if (hashObj == null) {
                    label = &quot;&quot;;
                } else {
                    label = &quot; (&quot; + Utils.getShortPubkeyName(hashObj.stringValue()) + &quot;)&quot;;
                }
                s = s.replaceFirst(&quot;^([a-zA-Z0-9-]+)_([a-zA-Z0-9-_]+)$&quot;, &quot;$1/$2&quot;);
                repos += &quot;&lt;li&gt;&lt;code&gt;&lt;a href=\&quot;/page/&quot; + s + &quot;\&quot;&gt;&quot; + s + &quot;&lt;/a&gt;&quot; + label + &quot;&lt;/code&gt;&lt;/li&gt;&quot;;
            }
            req.response()
                    .putHeader(&quot;content-type&quot;, &quot;text/html&quot;)
                    .end(&quot;&lt;!DOCTYPE html&gt;\n&quot;
                            + &quot;&lt;html lang='en'&gt;\n&quot;
                            + &quot;&lt;head&gt;\n&quot;
                            + &quot;&lt;title&gt;Nanopub Query: Pubkey Repos&lt;/title&gt;\n&quot;
                            + &quot;&lt;meta charset='utf-8'&gt;\n&quot;
                            + &quot;&lt;link rel=\&quot;stylesheet\&quot; href=\&quot;/style.css\&quot;&gt;\n&quot;
                            + &quot;&lt;/head&gt;\n&quot;
                            + &quot;&lt;body&gt;\n&quot;
                            + &quot;&lt;h3&gt;Pubkey Repos&lt;/h3&gt;&quot;
                            + &quot;&lt;p&gt;Repos:&lt;/p&gt;&quot;
                            + &quot;&lt;ul&gt;&quot; + repos + &quot;&lt;/ul&gt;&quot;
                            + &quot;&lt;/body&gt;\n&quot;
                            + &quot;&lt;/html&gt;&quot;);
        });
        proxyRouter.route(HttpMethod.GET, &quot;/types&quot;).handler(req -&gt; {
            String repos = &quot;&quot;;
            List&lt;String&gt; repoList = new ArrayList&lt;&gt;(TripleStore.get().getRepositoryNames());
            Collections.sort(repoList);
            for (String s : repoList) {
                if (!s.startsWith(&quot;type_&quot;)) continue;
                String hash = s.replaceFirst(&quot;^([a-zA-Z0-9-]+)_([a-zA-Z0-9-_]+)$&quot;, &quot;$2&quot;);
                Value hashObj = Utils.getObjectForHash(hash);
                String label;
                if (hashObj == null) {
                    label = &quot;&quot;;
                } else {
                    label = &quot; (&quot; + hashObj.stringValue() + &quot;)&quot;;
                }
                s = s.replaceFirst(&quot;^([a-zA-Z0-9-]+)_([a-zA-Z0-9-_]+)$&quot;, &quot;$1/$2&quot;);
                repos += &quot;&lt;li&gt;&lt;code&gt;&lt;a href=\&quot;/page/&quot; + s + &quot;\&quot;&gt;&quot; + s + &quot;&lt;/a&gt;&quot; + label + &quot;&lt;/code&gt;&lt;/li&gt;&quot;;
            }
            req.response()
                    .putHeader(&quot;content-type&quot;, &quot;text/html&quot;)
                    .end(&quot;&lt;!DOCTYPE html&gt;\n&quot;
                            + &quot;&lt;html lang='en'&gt;\n&quot;
                            + &quot;&lt;head&gt;\n&quot;
                            + &quot;&lt;title&gt;Nanopub Query: Type Repos&lt;/title&gt;\n&quot;
                            + &quot;&lt;meta charset='utf-8'&gt;\n&quot;
                            + &quot;&lt;link rel=\&quot;stylesheet\&quot; href=\&quot;/style.css\&quot;&gt;\n&quot;
                            + &quot;&lt;/head&gt;\n&quot;
                            + &quot;&lt;body&gt;\n&quot;
                            + &quot;&lt;h3&gt;Type Repos&lt;/h3&gt;&quot;
                            + &quot;&lt;p&gt;Repos:&lt;/p&gt;&quot;
                            + &quot;&lt;ul&gt;&quot; + repos + &quot;&lt;/ul&gt;&quot;
                            + &quot;&lt;/body&gt;\n&quot;
                            + &quot;&lt;/html&gt;&quot;);
        });
        proxyRouter.route(HttpMethod.GET, &quot;/style.css&quot;).handler(req -&gt; {
            if (css == null) {
                css = getResourceAsString(&quot;style.css&quot;);
            }
            req.response().end(css);
        });

        proxyRouter.route(HttpMethod.GET, &quot;/grlc-spec/*&quot;).handler(req -&gt; {
            GrlcSpecPage gsp = new GrlcSpecPage(req.normalizedPath(), req.queryParams());
            String spec = gsp.getSpec();
            if (spec == null) {
                req.response().setStatusCode(404).end(&quot;query definition not found / not valid&quot;);
            } else {
                req.response().putHeader(&quot;content-type&quot;, &quot;text/yaml&quot;).end(spec);
            }
        });

        proxyRouter.route(HttpMethod.GET, &quot;/openapi/spec/*&quot;).handler(req -&gt; {
            OpenApiSpecPage osp = new OpenApiSpecPage(req.normalizedPath(), req.queryParams());
            String spec = osp.getSpec();
            if (spec == null) {
                req.response().setStatusCode(404).end(&quot;query definition not found / not valid&quot;);
            } else {
                req.response().putHeader(&quot;content-type&quot;, &quot;text/yaml&quot;).end(spec);
            }
        });

        proxyRouter.route(&quot;/openapi/*&quot;).handler(StaticHandler.create(&quot;com/knowledgepixels/query/swagger&quot;));

        HttpProxy grlcProxy = HttpProxy.reverseProxy(httpClient);
        grlcProxy.origin(80, &quot;grlc&quot;);
<span class="nc" id="L327">        grlcProxy.addInterceptor(new ProxyInterceptor() {</span>

            @Override
            public Future&lt;ProxyResponse&gt; handleProxyRequest(ProxyContext context) {
<span class="nc" id="L331">                final String apiPattern = &quot;^/api/(RA[a-zA-Z0-9-_]{43})/([a-zA-Z0-9-_]+)([?].*)?$&quot;;</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">                if (context.request().getURI().matches(apiPattern)) {</span>
<span class="nc" id="L333">                    String artifactCode = context.request().getURI().replaceFirst(apiPattern, &quot;$1&quot;);</span>
<span class="nc" id="L334">                    String queryName = context.request().getURI().replaceFirst(apiPattern, &quot;$2&quot;);</span>
<span class="nc" id="L335">                    String grlcUrlParams = &quot;&quot;;</span>
<span class="nc" id="L336">                    String grlcSpecUrlParams = &quot;&quot;;</span>
<span class="nc" id="L337">                    MultiMap pm = context.request().proxiedRequest().params();</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">                    for (Entry&lt;String, String&gt; e : pm) {</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">                        if (e.getKey().equals(&quot;api-version&quot;)) {</span>
<span class="nc" id="L340">                            grlcSpecUrlParams += &quot;&amp;&quot; + e.getKey() + &quot;=&quot; + URLEncoder.encode(e.getValue(), Charsets.UTF_8);</span>
                        } else {
<span class="nc" id="L342">                            grlcUrlParams += &quot;&amp;&quot; + e.getKey() + &quot;=&quot; + URLEncoder.encode(e.getValue(), Charsets.UTF_8);</span>
                        }
<span class="nc" id="L344">                    }</span>
<span class="nc" id="L345">                    String url = &quot;/api-url/&quot; + queryName +</span>
<span class="nc" id="L346">                            &quot;?specUrl=&quot; + URLEncoder.encode(GrlcSpecPage.nanopubQueryUrl + &quot;grlc-spec/&quot; + artifactCode + &quot;/?&quot; +</span>
                            grlcSpecUrlParams, Charsets.UTF_8) + grlcUrlParams;
<span class="nc" id="L348">                    context.request().setURI(url);</span>
                }
<span class="nc" id="L350">                return context.sendRequest();</span>
            }

            @Override
            public Future&lt;Void&gt; handleProxyResponse(ProxyContext context) {
                // To avoid double entries:
<span class="nc" id="L356">                context.response().headers().remove(&quot;Access-Control-Allow-Origin&quot;);</span>
<span class="nc" id="L357">                return context.sendResponse();</span>
            }

        });

        proxyServer.requestHandler(req -&gt; {
            applyGlobalHeaders(req.response());
            proxyRouter.handle(req);
        });
        proxyServer.listen(9393);

        proxyRouter.route(&quot;/api/*&quot;).handler(ProxyHandler.create(grlcProxy));
        proxyRouter.route(&quot;/static/*&quot;).handler(ProxyHandler.create(grlcProxy));

        // Periodic metrics update
        vertx.setPeriodic(1000, id -&gt; collector.updateMetrics());


        new Thread(() -&gt; {
            try {
                var status = StatusController.get().initialize();
                System.err.println(&quot;Current state: &quot; + status.state + &quot;, last committed counter: &quot; + status.loadCounter);
                if (status.state == StatusController.State.LAUNCHING || status.state == StatusController.State.LOADING_INITIAL) {
                    // Do the initial nanopublication loading
                    StatusController.get().setLoadingInitial(status.loadCounter);
                    // Fall back to local nanopub loading if the local files are present
                    if (!LocalNanopubLoader.init()) {
                        JellyNanopubLoader.loadInitial(status.loadCounter);
                    } else {
                        System.err.println(&quot;Local nanopublication loading finished&quot;);
                    }
                    StatusController.get().setReady();
                } else {
                    System.err.println(&quot;Initial load is already done&quot;);
                    StatusController.get().setReady();
                }
            } catch (Exception ex) {
                ex.printStackTrace();
                System.err.println(&quot;Initial load failed, terminating...&quot;);
                Runtime.getRuntime().exit(1);
            }

            // Start periodic nanopub loading
            System.err.println(&quot;Starting periodic nanopub loading...&quot;);
            var executor = Executors.newSingleThreadScheduledExecutor();
            executor.scheduleWithFixedDelay(
                    JellyNanopubLoader::loadUpdates,
                    JellyNanopubLoader.UPDATES_POLL_INTERVAL,
                    JellyNanopubLoader.UPDATES_POLL_INTERVAL,
                    TimeUnit.MILLISECONDS
            );
        }).start();

        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {
            try {
                System.err.println(&quot;Gracefully shutting down...&quot;);
                TripleStore.get().shutdownRepositories();
                vertx.close().toCompletionStage().toCompletableFuture().get(5, TimeUnit.SECONDS);
                System.err.println(&quot;Graceful shutdown completed&quot;);
            } catch (Exception ex) {
                System.err.println(&quot;Graceful shutdown failed&quot;);
                ex.printStackTrace();
            }
        }));
    }

    private String getResourceAsString(String file) {
        InputStream is = getClass().getClassLoader().getResourceAsStream(&quot;com/knowledgepixels/query/&quot; + file);
        try (Scanner s = new Scanner(is).useDelimiter(&quot;\\A&quot;)) {
            String fileContent = s.hasNext() ? s.next() : &quot;&quot;;
            return fileContent;
        }
    }

    private static void handleRedirect(RoutingContext req, String path) {
        String queryString = &quot;&quot;;
        if (!req.queryParam(&quot;query&quot;).isEmpty())
            queryString = &quot;?query=&quot; + URLEncoder.encode(req.queryParam(&quot;query&quot;).get(0), Charsets.UTF_8);
        if (req.queryParam(&quot;for-type&quot;).size() == 1) {
            String type = req.queryParam(&quot;for-type&quot;).get(0);
            req.response().putHeader(&quot;location&quot;, path + &quot;/type/&quot; + Utils.createHash(type) + queryString);
            req.response().setStatusCode(301).end();
        } else if (req.queryParam(&quot;for-pubkey&quot;).size() == 1) {
            String type = req.queryParam(&quot;for-pubkey&quot;).get(0);
            req.response().putHeader(&quot;location&quot;, path + &quot;/pubkey/&quot; + Utils.createHash(type) + queryString);
            req.response().setStatusCode(301).end();
        } else if (req.queryParam(&quot;for-user&quot;).size() == 1) {
            String type = req.queryParam(&quot;for-user&quot;).get(0);
            req.response().putHeader(&quot;location&quot;, path + &quot;/user/&quot; + Utils.createHash(type) + queryString);
            req.response().setStatusCode(301).end();
        }
    }

    /**
     * Apply headers to the response that should be present for all requests.
     *
     * @param response The response to which the headers should be applied.
     */
    private static void applyGlobalHeaders(HttpServerResponse response) {
        response.putHeader(&quot;Nanopub-Query-Status&quot;, StatusController.get().getState().state.toString());
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>